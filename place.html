<!doctype html> <html> <!--Rewritten by gemini should i kill myself-->

<head>
    <meta charset="utf-8">
    <title>Pix</title>
    <meta name="title" content="meiplace" />
    <meta name="description" content="Placing it... ohhh..... im placing it....." />

    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://meisite.xyz/" />
    <meta property="og:title" content="meiplace" />
    <meta property="og:description" content="It's pronounced like the month of May." />
    <meta property="og:image" content="https://meisite.xyz/img/mei.png" />

    <link rel="stylesheet" type="text/css" href="style.css" />
    <script src="index.js"></script>
    <script src="js/toast.js"></script>
    <style>
        button {
            border-radius: 50px;
            padding: 10px;
            font-size: larger;
            background-color: #b84ac2;
            border: solid 2px #d193d6;

        }
    </style>
</head>

<body>

    <div id="toast-container">

    </div>

    <div class="page-container">

        <canvas id="place" width="800" height="300"
            style="background-color: #eee; image-rendering: pixelated;"></canvas>
        <div style="position: fixed; display:flex; width:100%; gap: 20px; justify-content:center; align-items:center;">
            <input type="color" id="colorpicker">
            <button id="submit">send</button>
            <button id="refresh">refresh</button>
            <button id="resetzoom">reset position</button>
            <button id="importimage">add image</button>
        </div>

        <script>
            const canvas = document.getElementById('place');
            const refreshbutton = document.getElementById('refresh');
            const resetzoombutton = document.getElementById('resetzoom');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            let pending = [];
            let scale = 1;
            let offsetX = 0, offsetY = 0;
            let drag = false, lastX, lastY;
            let panScaleX = 1, panScaleY = 1; // To hold coordinate scaling factors
            let shiftDown = false;
            document.addEventListener('keydown', (event) => {
                if (event.shiftKey) {
                    shiftDown = true;
                } else {
                    shiftDown = false;
                }
            });

            document.addEventListener('keyup', (event) => {
                if (event.shiftKey) {
                    shiftDown = false;
                }
            });

            // --- New state variables for image import ---
            let placingImage = null; // Will hold the Image() object
            let previewPos = { x: 0, y: 0 }; // Holds the top-left corner for the preview

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                ctx.imageSmoothingEnabled = false
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // initial sizing
            refreshbutton.addEventListener('click', function () { img.src = 'https://api.meisite.xyz/api/place/getcanvas?t=' + Date.now(); img.onload = () => requestAnimationFrame(draw); });
            resetzoombutton.addEventListener('click', function () { scale = 1; offsetX = 0; offsetY = 0; });

            function draw() {
                ctx.save();
                // Reset transform
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                // Clear canvas
                ctx.fillStyle = "#eeeeee";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Apply view transform
                ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

                // Draw the main image
                ctx.drawImage(img, 0, 0);

                // --- NEW: Draw image preview if we're placing one ---
                if (placingImage) {
                    ctx.globalAlpha = 0.7; // Make preview semi-transparent
                    ctx.drawImage(placingImage, previewPos.x, previewPos.y);
                    ctx.globalAlpha = 1.0; // Reset alpha
                }

                // Draw pending pixels
                for (const p of pending) {
                    ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},0.5)`;
                    ctx.fillRect(p.x, p.y, 1, 1);
                }

                // Draw grid lines
                if (scale > 5) {
                    ctx.strokeStyle = 'rgba(128,128,128,0.2)';
                    ctx.lineWidth = 1 / scale;
                    for (let i = 0; i <= 600; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0); ctx.lineTo(i, 600); ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(0, i); ctx.lineTo(600, i); ctx.stroke();
                    }
                }
                ctx.restore();
                requestAnimationFrame(draw); // Keep the draw loop going
            }

            img.src = 'https://api.meisite.xyz/api/place/getcanvas?t=' + Date.now();
            img.onload = () => requestAnimationFrame(draw);

            // --- NEW: Helper function to get mouse coords in world space ---
            function getMouseWorldCoords(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const canvasX = (e.clientX - rect.left) * scaleX;
                const canvasY = (e.clientY - rect.top) * scaleY;
                const worldX = Math.floor((canvasX - offsetX) / scale);
                const worldY = Math.floor((canvasY - offsetY) / scale);
                return { x: worldX, y: worldY };
            }

            // --- NEW: Helper function to process the image and add to pending ---
            function placeImagePixels(imgToPlace, startX, startY) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = imgToPlace.width;
                tempCanvas.height = imgToPlace.height;

                tempCtx.drawImage(imgToPlace, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                let pixelsAdded = 0;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];

                    // Only add non-transparent pixels (you can change 20 to 0)
                    if (a > 20) {
                        const pixelIndex = i / 4;
                        const localX = pixelIndex % tempCanvas.width;
                        const localY = Math.floor(pixelIndex / tempCanvas.width);

                        const worldX = startX + localX;
                        const worldY = startY + localY;

                        // Check canvas bounds
                        if (worldX < 600 && worldX >= 0 && worldY < 600 && worldY >= 0) {
                            pending.push({ x: worldX, y: worldY, color: [r, g, b] });
                            pixelsAdded++;
                            if(shiftDown == false)
                            {
                                placingImage = null;
                            }
                        }
                    }
                }
            }

            // --- NEW: Helper function to handle 'Escape' key ---
            function handleImagePlaceKey(e) {
                if (e.key === 'Escape' && placingImage) {
                    placingImage = null;
                    // Clean up this listener
                    window.removeEventListener('keydown', handleImagePlaceKey);
                }
            }

            // --- UPDATED: Click listener ---
            canvas.addEventListener('click', e => {
                const coords = getMouseWorldCoords(e);

                // --- NEW: Check if we are placing an image ---
                if (placingImage) {
                    placeImagePixels(placingImage, coords.x, coords.y);
                    placingImage = null; // Exit placement mode
                    window.removeEventListener('keydown', handleImagePlaceKey); // Clean up listener
                    e.preventDefault();
                    e.stopPropagation();
                    return; // Stop here
                }

                // --- Original pixel placement logic ---
                const worldX = coords.x;
                const worldY = coords.y;
                let color = document.getElementById("colorpicker").value
                let rgb = [
                    parseInt(color.slice(1, 3), 16),
                    parseInt(color.slice(3, 5), 16),
                    parseInt(color.slice(5, 7), 16)
                ];
                if (worldX < 600 & worldX >= 0 & worldY < 600 & worldY >= 0) {
                    pending.push({ x: worldX, y: worldY, color: rgb });
                }
            });

            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
                const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
                offsetX = mouseX - (mouseX - offsetX) * zoomFactor;
                offsetY = mouseY - (mouseY - offsetY) * zoomFactor;
                scale *= zoomFactor;
            });

            canvas.addEventListener('mousedown', e => {
                if (e.button == 1) { // Middle mouse
                    drag = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    const rect = canvas.getBoundingClientRect();
                    panScaleX = canvas.width / rect.width;
                    panScaleY = canvas.height / rect.height;
                }
            });

            // --- UPDATED: Mouse move listener ---
            canvas.addEventListener('mousemove', e => {
                // Handle panning
                if (drag) {
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;
                    offsetX += deltaX * panScaleX;
                    offsetY += deltaY * panScaleY;
                    lastX = e.clientX;
                    lastY = e.clientY;
                }

                // --- NEW: Handle image preview ---
                if (placingImage) {
                    const coords = getMouseWorldCoords(e);
                    previewPos.x = coords.x;
                    previewPos.y = coords.y;
                }
            });

            canvas.addEventListener('mouseup', e => {
                if (e.button == 1) { // Middle mouse
                    drag = false;
                }
            });

            canvas.addEventListener('contextmenu', e => {
                if (e.button == 1) e.preventDefault();
            });

            // --- NEW: 'add image' button listener ---
            document.getElementById('importimage').addEventListener('click', () => {
                // Create a temporary input element
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*'; // Accept all image types

                // Handle file selection
                input.onchange = e => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = res => {
                        const img = new Image();
                        img.onload = () => {
                            placingImage = img; // Set the global state
                            // Listen for the Escape key
                            window.addEventListener('keydown', handleImagePlaceKey);
                        };
                        img.src = res.target.result; // Load image from file data
                    };
                    reader.readAsDataURL(file);
                };

                //Trigger the file dialog
                input.click();
            });

            // --- Submit button (unchanged) ---
            document.getElementById('submit').addEventListener('click', () => {
                fetch('https://api.meisite.xyz/api/place/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pixels: pending })
                }).then(r => {
                    if (r.ok) {
                        pending = [];
                        img.src = 'https://api.meisite.xyz/api/place/getcanvas?t=' + Date.now();
                    }
                });
            });
        </script>

    </div>

</body>

</html>