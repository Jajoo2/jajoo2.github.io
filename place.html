<!doctype html> <!--This shit got rewritten by gemini i hate myself i wanna fucking die-->
<html>

<head>
    <meta charset="utf-8">
    <!-- Primary Meta Tags -->
    <title>Pix</title>
    <meta name="title" content="meiplace" />
    <meta name="description" content="Placing it... ohhh..... im placing it....." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://meisite.xyz/" />
    <meta property="og:title" content="meiplace" />
    <meta property="og:description" content="It's pronounced like the month of May." />
    <meta property="og:image" content="https://meisite.xyz/img/mei.png" />

    <link rel="stylesheet" type="text/css" href="style.css" />
    <script src="index.js"></script>
    <script src="js/toast.js"></script>
</head>

<body>

    <div id="toast-container">

    </div>

    <div class="page-container">

        <canvas id="place" width="800" height="300"
            style="background-color: #eee; image-rendering: pixelated;"></canvas>
        <div style="display:flex; width:100%; justify-content:center; align-items:center;">
            <input type="color" id="colorpicker">
            <button id="submit">send</button>
            <button id="refresh">refresh</button>
        </div>

        <script>
            const canvas = document.getElementById('place');
            const refreshbutton = document.getElementById('refresh');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            let pending = [];
            let scale = 1;
            let offsetX = 0, offsetY = 0;
            let drag = false, lastX, lastY;
            let panScaleX = 1, panScaleY = 1; // To hold coordinate scaling factors

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight-35;
                ctx.imageSmoothingEnabled = false
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // initial sizing
            refreshbutton.addEventListener('click', function() {img.src = 'https://api.meisite.xyz/api/place/getcanvas?t=' + Date.now(); img.onload = () => requestAnimationFrame(draw);});

            function draw() {
                ctx.save();
                // Reset transform to identity
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                // Clear canvas
                ctx.fillStyle = "#eeeeee";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Apply the view transform (scale and pan)
                // Note: The original code had redundant calls here. This is all you need.
                ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

                // Draw the main image
                ctx.drawImage(img, 0, 0);

                // Draw pending pixels with some transparency
                for (const p of pending) {
                    ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},0.5)`;
                    ctx.fillRect(p.x, p.y, 1, 1);
                }

                // Draw grid lines
                ctx.strokeStyle = 'rgba(128,128,128,0.2)'; // Made grid a bit more visible
                ctx.lineWidth = 1 / scale; // Keep grid lines thin when zoomed
                for (let i = 0; i <= 600; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0); ctx.lineTo(i, 600); ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i); ctx.lineTo(600, i); ctx.stroke();
                }
                ctx.restore();
                requestAnimationFrame(draw);
            }

            img.src = 'https://api.meisite.xyz/api/place/getcanvas?t=' + Date.now();
            img.onload = () => requestAnimationFrame(draw); // Use rAF for initial draw

            // --- FIX FOR PIXEL PLACEMENT ---
            canvas.addEventListener('click', e => {
                const rect = canvas.getBoundingClientRect();

                // 1. Calculate the ratio between the canvas resolution and its CSS display size.
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                // 2. Scale the mouse position (which is in CSS pixels) to canvas coordinates.
                const canvasX = (e.clientX - rect.left) * scaleX;
                const canvasY = (e.clientY - rect.top) * scaleY;

                // 3. Apply the inverse view transform to get the world coordinates.
                const worldX = Math.floor((canvasX - offsetX) / scale);
                const worldY = Math.floor((canvasY - offsetY) / scale);
                let color = document.getElementById("colorpicker").value
                let rgb = [
                    parseInt(color.slice(1, 3), 16),
                    parseInt(color.slice(3, 5), 16),
                    parseInt(color.slice(5, 7), 16)
                ];
                if(worldX < 600 & worldX >= 0 & worldY < 600 & worldY >= 0)
                {
                    pending.push({ x: worldX, y: worldY, color: rgb });
                }
            });

            canvas.addEventListener('wheel', e => {
                e.preventDefault();

                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;

                // adjust offset so the point under mouse stays in place
                offsetX = mouseX - (mouseX - offsetX) * zoomFactor;
                offsetY = mouseY - (mouseY - offsetY) * zoomFactor;

                scale *= zoomFactor;
            });


            // --- FIX FOR PANNING ---
            canvas.addEventListener('mousedown', e => {
                // e.button == 1 is the middle mouse button.
                if (e.button == 1) {
                    drag = true;
                    lastX = e.clientX;
                    lastY = e.clientY;

                    // Calculate the coordinate scaling factor at the beginning of the drag.
                    const rect = canvas.getBoundingClientRect();
                    panScaleX = canvas.width / rect.width;
                    panScaleY = canvas.height / rect.height;
                }
            });

            canvas.addEventListener('mousemove', e => {
                if (drag) {
                    // Calculate mouse movement in CSS pixels
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;

                    // Scale the movement delta to canvas coordinates and apply to offset
                    offsetX += deltaX * panScaleX;
                    offsetY += deltaY * panScaleY;

                    // Update the last mouse position
                    lastX = e.clientX;
                    lastY = e.clientY;
                }
            });

            // Only stop dragging if the middle mouse button is released.
            canvas.addEventListener('mouseup', e => {
                if (e.button == 1) {
                    drag = false;
                }
            });

            // This prevents the context menu from appearing on middle-click release
            canvas.addEventListener('contextmenu', e => {
                if (e.button == 1) e.preventDefault();
            });

            document.getElementById('submit').addEventListener('click', () => {
                fetch('https://api.meisite.xyz/api/place/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pixels: pending })
                }).then(r => {
                    if (r.ok) {
                        pending = [];
                        // Force a refresh of the image from the server
                        img.src = 'https://api.meisite.xyz/api/place/getcanvas?t=' + Date.now();
                    }
                });
            });
        </script>

    </div>


</body>

</html>